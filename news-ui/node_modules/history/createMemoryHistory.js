'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createTransitionManager = require('./createTransitionManager');

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlockAllPrompt = function BlockAllPrompt() {
  return false;
};

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var getUserConfirmation = props.getUserConfirmation;
  var _props$initialEntries = props.initialEntries;
  var initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries;
  var _props$initialIndex = props.initialIndex;
  var initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex;
  var _props$keyLength = props.keyLength;
  var keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  // Normalize entries based on type.

  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? { path: entry } : entry;
  });

  var currentState = {
    prevIndex: null,
    action: 'POP',
    index: clamp(initialIndex, 0, entries.length - 1),
    entries: entries
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(currentState, nextState);

    transitionManager.transitionTo(getCurrentLocation(), currentState.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  // Public interface

  var getCurrentLocation = function getCurrentLocation() {
    return currentState.entries[currentState.index];
  };

  var push = function push(path, state) {
    var action = 'PUSH';
    var key = createKey();
    var location = {
      path: path,
      state: state,
      key: key
    };

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = currentState.index;
      var nextIndex = prevIndex + 1;

      var entries = currentState.entries.slice(0);
      if (entries.length > nextIndex) {
        entries.splice(nextIndex, entries.length - nextIndex, location);
      } else {
        entries.push(location);
      }

      setState({
        prevIndex: currentState.index,
        action: action,
        index: nextIndex,
        entries: entries
      });
    });
  };

  var replace = function replace(path, state) {
    var action = 'REPLACE';
    var key = createKey();
    var location = {
      path: path,
      state: state,
      key: key
    };

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = currentState.index;
      var entries = currentState.entries.slice(0);

      entries[prevIndex] = location;

      setState({
        prevIndex: currentState.index,
        action: action,
        entries: entries
      });
    });
  };

  var go = function go(n) {
    var index = currentState.index;
    var entries = currentState.entries;

    var nextIndex = clamp(index + n, 0, entries.length - 1);

    var action = 'POP';
    var location = entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          prevIndex: index,
          action: action,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var index = currentState.index;
    var entries = currentState.entries;

    var nextIndex = index + n;

    return nextIndex >= 0 && nextIndex < entries.length;
  };

  var block = function block() {
    var prompt = arguments.length <= 0 || arguments[0] === undefined ? BlockAllPrompt : arguments[0];
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  return {
    getCurrentLocation: getCurrentLocation,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };
};

exports.default = createMemoryHistory;